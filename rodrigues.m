function [out jacob_out] = rodrigues(in)
%If size(in) == [3 3] returns rotation r1,r2,r3 
%If numel(in) == 3 returns rotational matrix correspondig r1,r2,r3
%
%Jacobians are currently calculated using inaccurate functions
%
%Matti Jukola 2010 / 2010.12.24 / 2011.02.05

if all(size(in) == [3 3])
    %Harley & Zisserman, Multiple View Geometry, pp.584-585
    %(A4.9) (A4.10) and (i), (ii) and (iii)
    %Solve (R-eye(3))*v=0. v is the unit rotation axis
    
    %Remove multipliers (experimental code)
    %These two lines are only needed if R is not a real rotation matrix
    %(for example when calculating camera matrix from homography)
    [U S V] = svd(in);
    in = U*V';
    
    [U S V] = svd(in-eye(3));
    v = V(:,end);
    
    co = (trace(in)-1)/2; %2*cos(phi) = trace(R)-1
    v_ = [in(3,2)-in(2,3);in(1,3)-in(3,1);in(2,1)-in(1,2)]; %This is 2*sin(phi)*v = v_
    si = v'*v_/2; %sin(phi) = v'*v_/2
    if si < eps*1e3 %In some cases 'si' will be very small
        ang = acos(co); %In these cases use usually more inaccurate method
    else
        %Usually atan2 gives us more accurate results
        ang = atan2(si,co); %Angle of rotation, phi
    end
    
    %If angle of rotation is small enough, we can quite safely say that
    %all rotations are 0
    if abs(ang) < eps*1e2
        out = zeros(3,1);
    else
        %Now output is
        out = 1/(2*sin(ang))*v_*ang;
    end
    
    if nargout > 1
        %Lets calculate jacobians piece by piece
        %Lets assume that R is real rotation matrix (and first SVD returns 
        %same matrix as was given to the function)
        
        %We have [r1 r2 r3 r4 r5 r6 r7 r8 r9]
        %R = [r1 r4 r7;
        %     r2 r5 r8;
        %     r3 r6 r9];
        
        %Now in 'co = (trace...' only diagonal values affect derivate
        jac_co = [1/2 0 0 0 1/2 0 0 0 1/2];
        
        %In v_ only few values of in affect derivate
        %First row R(3,2)-R(2,3)
        %Second row R(1,3)-R(3,1)
        %Third row R(2,1)-R(1,2)
        %       1 2 3 4 5 6 7 8 9
        jac_v_ = [0 0 0 0 0 1 0 -1 0;
                0 0 -1 0 0 0 1 0 0;
                0 1 0 -1 0 0 0 0 0];
        
        %For 'si' we multiply v' and jac_v and divide by 2. But this
        %is actually not used as we can get derivate of ang from
        %cos
        %jac_si = [0, v(3)/2, -v(2)/2, -v(3)/2, 0, v(1)/2, v(2)/2, -v(1)/2, 0];
        
        %Jacobian of ang
        %simple(jacobian(acos(co),[r1 r2 r3 r4 r5 r6 r7 r8 r9]))
        jac_ang = [-1/(4 - (r1 + r5 + in(9) - 1)^2)^(1/2), 0, 0, 0, -1/(4 - (in(1) + in(5) + in(9) - 1)^2)^(1/2), 0, 0, 0, -1/(4 - (in(1) + in(5) + in(9) - 1)^2)^(1/2)];
        
        %And finally outputs jacobian
        %syms ang
        %simple(jacobian(1/(2*sin(ang))*v_*ang;)
        
        
        jacob_out = rodjacob2(in,v);
    end
    
    %Following code from Yi Ma et. al. should not be used as it uses
    %acos which is numerically inaccurate and fails to solve in = pi
    %     %Yi Ma et. al. An Invitation to 3-D Vision  p. 27
    %     w_ = acos((trace(in)-1)/2);
    %     if w_ ~= 0
    %         out = 1/(2*sin(w_))*[in(3,2)-in(2,3);in(1,3)-in(3,1);in(2,1)-in(1,2)]*w_;
    %     else
    %        out = zeros(3,1);
    %     end
elseif numel(in) == 3
    %Yi Ma et. al. An Invitation to 3-D Vision  p. 27 (2.16)
    %Harley & Zisserman, Multiple View Geometry, p 585
    
    %Check if all angles are close to zero we can safely use eye(3) as
    %rotation matrix
    if all(abs(in) < eps*1e2)
        out = eye(3);
    else
        %Directly from Yi Ma et. al. (2.16) p.27
        out = eye(3) + makeSkew(in)/norm(in)*sin(norm(in)) + makeSkew(in)^2/norm(in)^2*(1-cos(norm(in)));
    end
    
    if nargout > 1
        jacob_out = rodjacob(in);
    end
else
    error('Input error');
end

return

%%%%%%%%%%%%%%%%%%%%%%%%%
%If you want to get angry, here is functions for creating
%jacobians generated from symbolic expressions (very inaccurate)
%%%%%%%%%%%%%%%%%%%%%%%%%

function RESULT = rodjacob(r)
%RODJACOB
%    RESULT = RODJACOB(A,B,C)

%    This function was generated by the Symbolic Math Toolbox version 5.1.
%    05-Feb-2011 18:28:39

%Generated using code:
% syms a b c
% in = [a b c];
% norm_in = sqrt(sum((in).^2));
% out = eye(3) + makeSkew(in)/norm_in*sin(norm_in) + makeSkew(in)^2/norm_in^2*(1-cos(norm_in));
% jacout = jacobian(out);

if norm(r) < eps
    RESULT = [0 0 0
        0 0 -1
        0 1 0
        0 0 1
        0 0 0
        -1 0 0
        0 -1 0
        1 0 0
        0 0 0];
     return;
end

a = r(1);
b = r(2);
c = r(3);
t4 = b.^2;
t5 = c.^2;
t6 = a.^2;
t7 = t4 + t5 + t6;
t8 = t7.^(1./2);
t9 = t4 + t5;
t10 = cos(t8);
t11 = t10 - 1;
t12 = sin(t8);
t13 = 1./t7.^(3./2);
t14 = 1./t7.^2;
t15 = 1./t7;
t16 = 1./t7.^(1./2);
t17 = 2.*a.*b.*c.*t11.*t14;
t18 = a.*b.*c.*t12.*t13;
t19 = b.*c.*t12.*t13;
t20 = 2.*b.*t11.*t14.*t6;
t21 = a.*c.*t12.*t13;
t22 = b.*t12.*t13.*t6;
t23 = 2.*a.*t11.*t14.*t4;
t24 = b.*c.*t10.*t15;
t25 = a.*t12.*t13.*t4;
t26 = t12.*t16;
t27 = t12.*t13.*t5;
t28 = t5 + t6;
t29 = 2.*c.*t11.*t15;
t30 = a.*b.*t10.*t15;
t31 = a.*c.*t10.*t15;
t32 = 2.*c.*t11.*t14.*t6;
t33 = a.*b.*t12.*t13;
t34 = c.*t12.*t13.*t6;
t35 = t10.*t15.*t4;
t36 = 2.*a.*t11.*t14.*t5;
t37 = a.*t12.*t13.*t5;
t38 = t12.*t13.*t6;
t39 = 2.*c.*t11.*t14.*t4;
t40 = c.*t12.*t13.*t4;
t41 = 2.*b.*t11.*t14.*t5;
t42 = b.*t12.*t13.*t5;
t43 = 2.*a.*t11.*t15;
t44 = t4 + t6;
t45 = 2.*b.*t11.*t15;
RESULT = [-2.*a.*t11.*t14.*t9-a.*t12.*t13.*t9,t45-2.*b.*t11.*t14.*t9-b.*t12.*t13.*t9,t29-2.*c.*t11.*t14.*t9-c.*t12.*t13.*t9;t20+t21+t22-b.*t11.*t15-a.*c.*t10.*t15,t19+t23+t25-a.*t11.*t15-b.*c.*t10.*t15,t17+t18+t27-t12.*t16-t10.*t15.*t5;t30+t32+t34-c.*t11.*t15-a.*b.*t12.*t13,t17+t18+t26+t35-t12.*t13.*t4,t24-t19+t36+t37-a.*t11.*t15;t20-t21+t22+t31-b.*t11.*t15,t23-t19+t24+t25-a.*t11.*t15,t17+t18+t26-t27+t10.*t15.*t5;t43-2.*a.*t11.*t14.*t28-a.*t12.*t13.*t28,-2.*b.*t11.*t14.*t28-b.*t12.*t13.*t28,t29-2.*c.*t11.*t14.*t28-c.*t12.*t13.*t28;t17+t18-t26+t38-t10.*t15.*t6,t33-t30+t39+t40-c.*t11.*t15,t21-t31+t41+t42-b.*t11.*t15;t32-t30+t33+t34-c.*t11.*t15,t17+t18-t26-t35+t12.*t13.*t4,t19-t24+t36+t37-a.*t11.*t15;t17+t18+t26-t38+t10.*t15.*t6,t30-t33+t39+t40-c.*t11.*t15,t31-t21+t41+t42-b.*t11.*t15;t43-2.*a.*t11.*t14.*t44-a.*t12.*t13.*t44,t45-2.*b.*t11.*t14.*t44-b.*t12.*t13.*t44,-2.*c.*t11.*t14.*t44-c.*t12.*t13.*t44];
return


function RESULT = rodjacob2(R,v)
%RODJACOB2
%    RESULT = RODJACOB2(R1,R2,R3,R4,R5,R6,R7,R8,R9,V1,V2,V3)

%    This function was generated by the Symbolic Math Toolbox version 5.1.
%    05-Feb-2011 20:21:32

%Generated using code:
% syms v1 v2 v3
% syms r1 r2 r3 r4 r5 r6 r7 r8 r9
% v = [v1 v2 v3].';
% in = [r1 r2 r3;r4 r5 r6;r7 r8 r9].';
% co = (trace(in)-1)/2; %2*cos(phi) = trace(R)-1
% v_ = [in(3,2)-in(2,3);in(1,3)-in(3,1);in(2,1)-in(1,2)]; %This is 2*sin(phi)*v = v_
% si = v.'*v_/2; %sin(phi) = v'*v_/2
% ang = 2*atan(si./(sqrt(co^2+si^2)+co)); %Angle of rotation, phi
% out = 1/(2*sin(ang))*[in(3,2)-in(2,3);in(1,3)-in(3,1);in(2,1)-in(1,2)]*ang;    
% jacout = jacobian(out);

if all(all((R-eye(3))<eps*1e3))
    RESULT =[0 0 0 0 0 0.5 0 -0.5 0;
             0 0 -0.5 0 0 0 0.5 0 0;
             0 0.5 0 -0.5 0 0 0 0 0];
    return
end

r1 = R(1);
r2 = R(2);
r3 = R(3);
r4 = R(4);
r5 = R(5);
r6 = R(6);
r7 = R(7);
r8 = R(8);
r9 = R(9);
v1 = v(1);
v2 = v(2);
v3 = v(3);

t4 = r2 - r4;
t5 = (t4.*v3)./2;
t6 = r3 - r7;
t7 = r6 - r8;
t8 = (t7.*v1)./2;
t14 = (t6.*v2)./2;
t9 = t5 - t14 + t8;
t10 = r1./2;
t11 = r5./2;
t12 = r9./2;
t13 = t10 + t11 + t12 - 1./2;
t15 = t9.^2;
t16 = t13.^2;
t17 = t15 + t16;
t18 = t17.^(1./2);
t19 = t10 + t11 + t12 + t18 - 1./2;
t20 = 1./t19.^2;
t21 = 1./t19;
t22 = t21.*t9;
t23 = atan(t22);
t24 = 2.*t23;
t25 = sin(t24);
t26 = t15.*t20;
t27 = t26 + 1;
t28 = 1./t27;
t29 = 1./t17.^(1./2);
t30 = (t13.*t29)./2;
t31 = t30 + 1./2;
t32 = 1./t25;
t33 = cos(t24);
t34 = 1./t25.^2;
t35 = (t21.*v3)./2;
t39 = (t15.*t20.*t29.*v3)./2;
t36 = t35 - t39;
t37 = (t21.*v2)./2;
t45 = (t15.*t20.*t29.*v2)./2;
t38 = t37 - t45;
t40 = t28.*t32.*t36.*t7;
t41 = 2.*t20.*t23.*t28.*t31.*t33.*t34.*t7.*t9;
t50 = t20.*t28.*t31.*t32.*t7.*t9;
t42 = t41 - t50;
t43 = (t21.*v1)./2;
t48 = (t15.*t20.*t29.*v1)./2;
t44 = t43 - t48;
t46 = 2.*t23.*t28.*t33.*t34.*t38.*t7;
t47 = t23.*t32;
t49 = t28.*t32.*t44.*t7;
t51 = 2.*t23.*t28.*t33.*t34.*t36.*t6;
t52 = t20.*t28.*t31.*t32.*t6.*t9;
t56 = 2.*t20.*t23.*t28.*t31.*t33.*t34.*t6.*t9;
t53 = t52 - t56;
t54 = t28.*t32.*t38.*t6;
t55 = 2.*t23.*t28.*t33.*t34.*t44.*t6;
t57 = t28.*t32.*t36.*t4;
t58 = 2.*t20.*t23.*t28.*t31.*t33.*t34.*t4.*t9;
t62 = t20.*t28.*t31.*t32.*t4.*t9;
t59 = t58 - t62;
t60 = 2.*t23.*t28.*t33.*t34.*t38.*t4;
t61 = t28.*t32.*t4.*t44;
RESULT = [t42,t40-2.*t23.*t28.*t33.*t34.*t36.*t7,t46-t28.*t32.*t38.*t7,2.*t23.*t28.*t33.*t34.*t36.*t7-t40,t42,t47+t49-2.*t23.*t28.*t33.*t34.*t44.*t7,t28.*t32.*t38.*t7-t46,2.*t23.*t28.*t33.*t34.*t44.*t7-t49-t47,t42;t53,t51-t28.*t32.*t36.*t6,t54-t47-2.*t23.*t28.*t33.*t34.*t38.*t6,t28.*t32.*t36.*t6-t51,t53,t55-t28.*t32.*t44.*t6,t47-t54+2.*t23.*t28.*t33.*t34.*t38.*t6,t28.*t32.*t44.*t6-t55,t53;t59,t47+t57-2.*t23.*t28.*t33.*t34.*t36.*t4,t60-t28.*t32.*t38.*t4,2.*t23.*t28.*t33.*t34.*t36.*t4-t57-t47,t59,t61-2.*t23.*t28.*t33.*t34.*t4.*t44,t28.*t32.*t38.*t4-t60,2.*t23.*t28.*t33.*t34.*t4.*t44-t61,t59];
return